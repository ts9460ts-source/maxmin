<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>2次関数Maxmin タイムアタックチャレンジ</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Hiragino Kaku Gothic ProN', 'メイリオ', sans-serif; line-height: 1.8; background-color: #f0f4f8; color: #333; }
        .container { max-width: 800px; margin: 20px auto; padding: 25px; background-color: #fff; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        h1, h2 { text-align: center; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .btn { display: inline-block; padding: 12px 25px; font-size: 18px; font-weight: bold; color: #fff; background-color: #3498db; border: none; border-radius: 5px; cursor: pointer; transition: all 0.3s; margin: 5px; text-decoration: none; }
        .btn:hover { background-color: #2980b9; transform: translateY(-2px); }
        .btn-secondary { background-color: #2ecc71; }
        .btn-secondary:hover { background-color: #27ae60; }
        #start-screen, #result-screen { text-align: center; padding: 20px 0; }
        #game-screen { display: none; }
        .game-header { display: flex; justify-content: space-between; align-items: center; padding: 10px; background-color: #34495e; color: white; border-radius: 8px; margin-bottom: 20px; }
        .game-status { font-size: 1.2em; font-weight: bold; }
        .timer { font-size: 1.5em; font-family: 'Courier New', Courier, monospace; }
        #problem-display { padding: 25px; margin-top: 20px; border: 1px solid #ccc; border-radius: 8px; font-size: 1.25em; }
        .input-group { margin-bottom: 15px; display: flex; align-items: center; flex-wrap: wrap; justify-content: center; }
        .input-group label { width: auto; font-weight: bold; margin-right: 10px; }
        .input-group input[type="text"] { width: 100px; padding: 8px; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }
        #result-display { margin-top: 20px; padding: 15px; border-radius: 5px; font-weight: bold; text-align: center; }
        .correct { background-color: #d4edda; color: #155724; }
        .incorrect { background-color: #f8d7da; color: #721c24; }
        #explanation-area { display: none; margin-top: 15px; padding: 20px; background-color: #fff3cd; border-left: 5px solid #ffeeba; border-radius: 5px; }
        #graph-container { margin: 15px auto; text-align: center; }
    </style>
</head>
<body>
<div class="container">
    <h1>2次関数Maxmin タイムアタックチャレンジ ⏱️</h1>
    <center><p>レベル１は定義域なし、レベル２は定義域あり</p></center>
    <div id="start-screen">
        <h2>挑戦するレベルを選択</h2>
        <div class="input-group" style="margin-bottom: 20px;"><label for="start-nickname">ニックネーム:</label><input type="text" id="start-nickname" value="挑戦者" style="width: 200px;"></div>
        <div id="high-score-display" style="background-color: #ecf0f1; padding: 15px; border-radius: 8px; margin: 20px 0; text-align: center; font-size: 1.1em;"><p>ハイスコア (レベル1): <span id="high-score-1">0</span> 点</p><p>ハイスコア (レベル2): <span id="high-score-2">0</span> 点</p></div>
        <button class="btn" onclick="startGame(1)">レベル1 に挑戦</button><button class="btn btn-secondary" onclick="startGame(2)">レベル2 に挑戦</button><a href="ranking.html" target="_blank" class="btn" style="text-decoration: none; background-color: #95a5a6;">オンラインランキングを見る</a>
    </div>
    <div id="game-screen">
        <div class="game-header"><div class="game-status"><span id="stage-info"></span> | 問 <span id="question-number"></span> / 3</div><div class="timer" id="timer-display">0.00</div></div>
        <div id="problem-display"></div><div id="answer-form"></div><div id="result-display"></div>
        <div id="explanation-area">
            <h4>💡 解説</h4>
            <div id="graph-container"></div>
            <div id="explanation-text"></div>
            <button class="btn" onclick="resumeGame()">次の問題へ</button>
        </div>
    </div>
    <div id="result-screen" style="display: none;">
        <h2>ゲーム終了！</h2><p style="font-size: 1.5em; font-weight: bold;">最終スコア: <span id="final-score">0</span> 点</p>
        <div class="input-group"><label for="nickname">ニックネーム:</label><input type="text" id="nickname" readonly style="width: 200px; background-color: #eee;"></div>
        <button class="btn btn-secondary" onclick="saveScore()">オンラインランキングに登録</button><button class="btn" onclick="restartGame()" style="background-color: #3498db;">最初に戻る</button><a href="ranking.html" target="_blank" class="btn" style="background-color: #95a5a6;">ランキングを見る</a>
    </div>
</div>
<script>
    const GAS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwgt8KL6p9Vk2lD1dyYGZVsTYsTHnTT52Sc0PBZA1uEQjAMQWi_pjFxxIF4WpaFQ6qv/exec';
    let gameState = {};
    let timerInterval;

    const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const getNonZeroRandomInt = (min, max) => { let n; do { n = getRandomInt(min, max); } while (n === 0); return n; };
    const formatCoefficient = (n, v = '', isFirst = false) => { if (n === 0) return ''; const sign = n > 0 ? (isFirst ? '' : ' + ') : ' - '; const absN = Math.abs(n); const num = (absN === 1 && v !== '') ? '' : absN; return `${sign}${num}${v}`; };
    const sanitizeInput = (input) => { input.value = input.value.replace(/[^0-9-]/g, ''); };

    document.addEventListener('DOMContentLoaded', () => {
        updateHighScoreDisplay();
        document.getElementById('start-nickname').value = localStorage.getItem('lastNickname') || '挑戦者';
    });

    function updateHighScoreDisplay() {
        document.getElementById('high-score-1').textContent = localStorage.getItem('highScore_level1') || 0;
        document.getElementById('high-score-2').textContent = localStorage.getItem('highScore_level2') || 0;
    }

    function startGame(level) {
        const nickname = document.getElementById('start-nickname').value || '挑戦者';
        localStorage.setItem('lastNickname', nickname);
        gameState = { level: level, nickname: nickname, questionIndex: 0, questionScores: [0, 0, 0], elapsedTime: 0, isPaused: false };
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'block';
        startTimer();
        nextQuestion();
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        const startTime = Date.now() - gameState.elapsedTime;
        timerInterval = setInterval(() => {
            if (!gameState.isPaused) {
                gameState.elapsedTime = Date.now() - startTime;
                document.getElementById('timer-display').textContent = (gameState.elapsedTime / 1000).toFixed(2);
            }
        }, 10);
    }

    function restartGame() {
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'block';
        updateHighScoreDisplay();
    }

    function nextQuestion() {
        if (gameState.questionIndex >= 3) {
            endGame();
            return;
        }
        document.getElementById('stage-info').textContent = `レベル ${gameState.level}`;
        document.getElementById('question-number').textContent = gameState.questionIndex + 1;
        document.getElementById('result-display').style.display = 'none';
        document.getElementById('explanation-area').style.display = 'none';
        generateQuestion();
        MathJax.typesetPromise();
    }

    function checkAnswer() {
        gameState.isPaused = true;
        let isMaxCorrect = false, isMinCorrect = false;
        const p = gameState.currentProblem;
        const maxVal = document.getElementById('max-val').value, maxX = document.getElementById('max-x').value, maxNone = document.getElementById('max-none')?.checked;
        const minVal = document.getElementById('min-val').value, minX = document.getElementById('min-x').value, minNone = document.getElementById('min-none')?.checked;
        if(gameState.level === 1){
            if (p.a > 0) { isMinCorrect = (minVal == p.q && minX == p.p); isMaxCorrect = maxNone; }
            else { isMaxCorrect = (maxVal == p.q && maxX == p.p); isMinCorrect = minNone; }
        } else {
            isMaxCorrect = (maxVal == p.maxValue && maxX == p.maxX);
            isMinCorrect = (minVal == p.minValue && minX == p.minX);
        }

        const potentialScore = calculatePotentialScore(gameState.elapsedTime, gameState.level, gameState.questionIndex);
        let currentScore = 0;
        let resultText = '';
        if(isMaxCorrect && isMinCorrect){
            currentScore = potentialScore; resultText = `正解！ ${currentScore}点獲得！`;
        } else if (isMaxCorrect || isMinCorrect) {
            currentScore = Math.round(potentialScore / 2); resultText = `部分正解！ ${currentScore}点獲得！`;
        } else {
            currentScore = 0; resultText = '不正解...！ 0点';
        }
        gameState.questionScores[gameState.questionIndex] = currentScore;
        const resultDisplay = document.getElementById('result-display');
        resultDisplay.className = (isMaxCorrect && isMinCorrect) ? 'correct' : 'incorrect';
        resultDisplay.textContent = resultText;
        resultDisplay.style.display = 'block';
        if (isMaxCorrect && isMinCorrect) {
            gameState.questionIndex++;
            setTimeout(() => { gameState.isPaused = false; nextQuestion(); }, 1500);
        } else {
            resultDisplay.textContent += ' タイムは停止しています。';
            showExplanation();
        }
    }
    
    function resumeGame() {
        gameState.questionIndex++;
        gameState.isPaused = false;
        nextQuestion();
    }

    function showExplanation() {
        const p = gameState.currentProblem;
        const explanationTextArea = document.getElementById('explanation-text');
        const graphContainer = document.getElementById('graph-container');
        let html = '';

        if(gameState.level === 1){
            graphContainer.style.display = 'none';
            html += `<p>この式から、頂点は (\\(${p.p}, ${p.q}\\)) です。</p>`;
            html += p.a > 0 ? `<p>グラフは下に凸 (∪の形) なので、頂点で<strong>最小値</strong> \\(${p.q}\\) (x=\\(${p.p}\\))をとります。<br>最大値はありません。</p>` : `<p>グラフは上に凸 (∩の形) なので、頂点で<strong>最大値</strong> \\(${p.q}\\) (x=\\(${p.p}\\))をとります。<br>最小値はありません。</p>`;
        } else {
            graphContainer.style.display = 'block';
            const axisX = p.p;
            html += `<p>平方完成すると、軸は直線 \\(x = ${axisX}\\) であることが分かります。</p><p>次に、下のグラフのように軸と定義域 \\(${p.d1} \\le x \\le ${p.d2}\\) の位置関係を考えます。</p><ul>`;
            if (axisX < p.d1) {
                 html += `<li>軸 (赤線) は定義域 (緑の範囲) の<strong>左外側</strong>にあります。</li>`;
                 html += p.a > 0 ? `<li>したがって、軸に最も近い定義域の左端 (x=${p.d1}) で最小値、最も遠い右端 (x=${p.d2}) で最大値をとります。</li>` : `<li>したがって、軸に最も近い定義域の左端 (x=${p.d1}) で最大値、最も遠い右端 (x=${p.d2}) で最小値をとります。</li>`;
            } else if (axisX > p.d2) {
                 html += `<li>軸 (赤線) は定義域 (緑の範囲) の<strong>右外側</strong>にあります。</li>`;
                 html += p.a > 0 ? `<li>したがって、軸に最も近い定義域の右端 (x=${p.d2}) で最小値、最も遠い左端 (x=${p.d1}) で最大値をとります。</li>` : `<li>したがって、軸に最も近い定義域の右端 (x=${p.d2}) で最大値、最も遠い左端 (x=${p.d1}) で最小値をとります。</li>`;
            } else {
                html += `<li>軸 (赤線) は定義域 (緑の範囲) の<strong>内側</strong>にあります。</li>`;
                html += p.a > 0 ? `<li>下に凸のグラフなので、頂点 (x=${axisX}) で最小値をとります。</li><li>最大値は、軸から最も遠い定義域の端 (x=${p.maxX}) でとります。</li>` : `<li>上に凸のグラフなので、頂点 (x=${axisX}) で最大値をとります。</li><li>最小値は、軸から最も遠い定義域の端 (x=${p.minX}) でとります。</li>`;
            }
            html += `</ul><p><b>[正解]</b> 最大値: ${p.maxValue} (x=${p.maxX}), 最小値: ${p.minValue} (x=${p.minX})</p>`;
            drawSVGGraph(p);
        }
        
        explanationTextArea.innerHTML = html;
        document.getElementById('explanation-area').style.display = 'block';
        MathJax.typesetPromise();
    }

    // ▼▼▼ SVGグラフ描画関数（新） ▼▼▼
    function drawSVGGraph(p) {
        const func = x => p.a * (x - p.p)**2 + p.q;
        const yAtD1 = func(p.d1);
        const yAtD2 = func(p.d2);

        const xMin = Math.min(p.d1, p.p) - 2;
        const xMax = Math.max(p.d2, p.p) + 2;
        const yMin = Math.min(yAtD1, yAtD2, p.q) - 5;
        const yMax = Math.max(yAtD1, yAtD2, p.q) + 5;
        
        const width = 400;
        const height = 300;
        const xRange = xMax - xMin;
        const yRange = yMax - yMin;
        
        const toSvgX = x => ((x - xMin) / xRange) * width;
        const toSvgY = y => height - ((y - yMin) / yRange) * height;

        let svg = `<svg width="${width}" height="${height}" style="border: 1px solid #ccc; background-color: #fff;">`;
        
        // 軸
        svg += `<line x1="${toSvgX(0)}" y1="0" x2="${toSvgX(0)}" y2="${height}" stroke="#ccc" />`;
        svg += `<line x1="0" y1="${toSvgY(0)}" x2="${width}" y2="${toSvgY(0)}" stroke="#ccc" />`;
        
        // 定義域の範囲をシェード
        svg += `<rect x="${toSvgX(p.d1)}" y="0" width="${toSvgX(p.d2) - toSvgX(p.d1)}" height="${height}" fill="rgba(75, 192, 192, 0.2)" />`;
        
        // 放物線
        let pathData = "M";
        const steps = 100;
        for(let i=0; i<=steps; i++) {
            const x = xMin + (xRange / steps) * i;
            const y = func(x);
            pathData += ` ${toSvgX(x)},${toSvgY(y)}`;
            if(i > 0) pathData += ' L';
        }
        svg += `<path d="${pathData.slice(0,-2)}" stroke="rgb(54, 162, 235)" stroke-width="3" fill="none" />`;
        
        // 軸
        svg += `<line x1="${toSvgX(p.p)}" y1="0" x2="${toSvgX(p.p)}" y2="${height}" stroke="rgb(255, 99, 132)" stroke-dasharray="5,5" stroke-width="2" />`;
        
        // ラベル
        svg += `<text x="${toSvgX(p.p) + 5}" y="${toSvgY(yMax-2)}" fill="rgb(255, 99, 132)">軸 x=${p.p}</text>`;
        svg += `<text x="${toSvgX(p.d1)}" y="${height-5}" fill="rgb(75, 192, 192)" text-anchor="middle">${p.d1}</text>`;
        svg += `<text x="${toSvgX(p.d2)}" y="${height-5}" fill="rgb(75, 192, 192)" text-anchor="middle">${p.d2}</text>`;
        svg += `<text x="${width-10}" y="${toSvgY(0)-5}" fill="#333" text-anchor="end">x</text>`;
        svg += `<text x="${toSvgX(0)+5}" y="15" fill="#333">y</text>`;

        svg += '</svg>';
        document.getElementById('graph-container').innerHTML = svg;
    }

    function calculatePotentialScore(timeMillis, level, qIndex) {
        const timeSeconds = timeMillis / 1000;
        const BASE_SCORES = [8000, 10000, 12000];
        const levelMultiplier = (level === 1) ? 1.0 : 1.5;
        const timePenalty = timeSeconds * 10;
        const rawScore = (BASE_SCORES[qIndex] - timePenalty) * levelMultiplier;
        return Math.round(Math.max(100, rawScore));
    }

    function endGame() {
        clearInterval(timerInterval);
        const finalScore = gameState.questionScores.reduce((sum, score) => sum + score, 0);
        document.getElementById('game-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'block';
        document.getElementById('final-score').textContent = finalScore;
        document.getElementById('nickname').value = gameState.nickname;
        const highScoreKey = `highScore_level${gameState.level}`;
        const currentHighScore = parseInt(localStorage.getItem(highScoreKey) || '0');
        if (finalScore > currentHighScore) { localStorage.setItem(highScoreKey, finalScore); }
        gameState.finalScore = finalScore;
    }

    async function saveScore() {
        const saveButton = document.querySelector('#result-screen .btn-secondary');
        saveButton.disabled = true;
        saveButton.textContent = '登録中...';
        const payload = { nickname: gameState.nickname, score: gameState.finalScore, level: gameState.level };
        try {
            await fetch(GAS_WEB_APP_URL, { method: 'POST', mode: 'no-cors', cache: 'no-cache', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            saveButton.textContent = '登録完了！';
        } catch (error) {
            alert('登録に失敗しました。');
            saveButton.textContent = 'オンラインランキングに登録';
            saveButton.disabled = false;
        }
    }
    
    function generateQuestion() {
        let a, p, q, d1, d2, mathExpression = '', answerFormHTML = '';
        const qIndex = gameState.questionIndex;
        if (qIndex === 0) { a = (Math.random() < 0.5) ? 1 : -1; }
        else if (qIndex === 1) { a = 1; }
        else { a = [-2, -1, 2][getRandomInt(0, 2)]; }
        if (gameState.level === 2) {
            d1 = getRandomInt(-5, 0); d2 = d1 + getRandomInt(4, 8);
            const axisCase = getRandomInt(1, 3);
            if (axisCase === 1) { p = getRandomInt(d1, d2); }
            else if (axisCase === 2) { p = d1 - getRandomInt(1, 3); }
            else { p = d2 + getRandomInt(1, 3); }
        } else { p = getNonZeroRandomInt(-5, 5); }
        q = getNonZeroRandomInt(-8, 8);
        if (qIndex === 0) { mathExpression = `y = ${formatCoefficient(a, `(x ${p > 0 ? '-' : '+'} ${Math.abs(p)})^2`, true)} ${formatCoefficient(q)}`; }
        else { const b = -2 * a * p; const c = a * p * p + q; mathExpression = `y = ${formatCoefficient(a, 'x^2', true)} ${formatCoefficient(b, 'x')} ${formatCoefficient(c)}`; }
        gameState.currentProblem = { a, p, q };
        if (gameState.level === 1) {
            answerFormHTML = `<p>最大値・最小値を求め、値がない場合は「なし」にチェック</p><div class="input-group" style="justify-content: left;"><label>最大値:</label><input type="text" id="max-val" oninput="sanitizeInput(this)"><span>(x=</span><input type="text" id="max-x" oninput="sanitizeInput(this)"><span>)</span><label style="margin-left:10px;"><input type="checkbox" id="max-none">なし</label></div><div class="input-group" style="justify-content: left;"><label>最小値:</label><input type="text" id="min-val" oninput="sanitizeInput(this)"><span>(x=</span><input type="text" id="min-x" oninput="sanitizeInput(this)"><span>)</span><label style="margin-left:10px;"><input type="checkbox" id="min-none">なし</label></div><button class="btn" onclick="checkAnswer()">解答</button>`;
        } else {
            Object.assign(gameState.currentProblem, { d1, d2 });
            mathExpression += ` \\quad (${d1} \\le x \\le ${d2})`;
            const y1 = a * (d1-p)**2 + q, y2 = a * (d2-p)**2 + q;
            let maxValue, maxX, minValue, minX;
            if (a > 0) {
                if (p < d1) { minValue = y1; minX = d1; maxValue = y2; maxX = d2; }
                else if (p > d2) { minValue = y2; minX = d2; maxValue = y1; maxX = d1; }
                else { minValue = q; minX = p; maxValue = Math.max(y1, y2); maxX = Math.abs(d1 - p) > Math.abs(d2 - p) ? d1 : d2; }
            } else {
                if (p < d1) { maxValue = y1; maxX = d1; minValue = y2; minX = d2; }
                else if (p > d2) { maxValue = y2; maxX = d2; minValue = y1; minX = d1; }
                else { maxValue = q; maxX = p; minValue = Math.min(y1, y2); minX = Math.abs(d1 - p) > Math.abs(d2 - p) ? d1 : d2; }
            }
            Object.assign(gameState.currentProblem, { maxValue, maxX, minValue, minX });
            answerFormHTML = `<p>最大値と最小値、そのときのxの値を答えよ。</p><div class="input-group" style="justify-content: left;"><label>最大値:</label><input type="text" id="max-val" oninput="sanitizeInput(this)"><span>(x=</span><input type="text" id="max-x" oninput="sanitizeInput(this)"><span>)</span></div><div class="input-group" style="justify-content: left;"><label>最小値:</label><input type="text" id="min-val" oninput="sanitizeInput(this)"><span>(x=</span><input type="text" id="min-x" oninput="sanitizeInput(this)"><span>)</span></div><button class="btn" onclick="checkAnswer()">解答</button>`;
        }
        const problemText = `\\[ ${mathExpression} \\]`;
        document.getElementById('problem-display').innerHTML = `<p>${problemText}</p>`;
        document.getElementById('answer-form').innerHTML = answerFormHTML;
    }
</script>
</body>
</html>